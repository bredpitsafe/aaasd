// @ts-nocheck

// Generated by peggy v. 2.0.1 (ts-pegjs plugin v. 2.2.1 )
//
// https://peggyjs.org/   https://github.com/metadevpro/ts-pegjs

"use strict";

export interface IFilePosition {
  offset: number;
  line: number;
  column: number;
}

export interface IFileRange {
  start: IFilePosition;
  end: IFilePosition;
  source: string;
}

export interface ILiteralExpectation {
  type: "literal";
  text: string;
  ignoreCase: boolean;
}

export interface IClassParts extends Array<string | IClassParts> {}

export interface IClassExpectation {
  type: "class";
  parts: IClassParts;
  inverted: boolean;
  ignoreCase: boolean;
}

export interface IAnyExpectation {
  type: "any";
}

export interface IEndExpectation {
  type: "end";
}

export interface IOtherExpectation {
  type: "other";
  description: string;
}

export type Expectation = ILiteralExpectation | IClassExpectation | IAnyExpectation | IEndExpectation | IOtherExpectation;

function peg$padEnd(str: string, targetLength: number, padString: string) {
  padString = padString || ' ';
  if (str.length > targetLength) {
    return str;
  }
  targetLength -= str.length;
  padString += padString.repeat(targetLength);
  return str + padString.slice(0, targetLength);
}

export class SyntaxError extends Error {
  public static buildMessage(expected: Expectation[], found: string | null) {
    function hex(ch: string): string {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }

    function literalEscape(s: string): string {
      return s
        .replace(/\\/g, "\\\\")
        .replace(/"/g,  "\\\"")
        .replace(/\0/g, "\\0")
        .replace(/\t/g, "\\t")
        .replace(/\n/g, "\\n")
        .replace(/\r/g, "\\r")
        .replace(/[\x00-\x0F]/g,            (ch) => "\\x0" + hex(ch) )
        .replace(/[\x10-\x1F\x7F-\x9F]/g, (ch) => "\\x"  + hex(ch) );
    }

    function classEscape(s: string): string {
      return s
        .replace(/\\/g, "\\\\")
        .replace(/\]/g, "\\]")
        .replace(/\^/g, "\\^")
        .replace(/-/g,  "\\-")
        .replace(/\0/g, "\\0")
        .replace(/\t/g, "\\t")
        .replace(/\n/g, "\\n")
        .replace(/\r/g, "\\r")
        .replace(/[\x00-\x0F]/g,            (ch) => "\\x0" + hex(ch) )
        .replace(/[\x10-\x1F\x7F-\x9F]/g, (ch) => "\\x"  + hex(ch) );
    }

    function describeExpectation(expectation: Expectation) {
      switch (expectation.type) {
        case "literal":
          return "\"" + literalEscape(expectation.text) + "\"";
        case "class":
          const escapedParts = expectation.parts.map((part) => {
            return Array.isArray(part)
              ? classEscape(part[0] as string) + "-" + classEscape(part[1] as string)
              : classEscape(part);
          });

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        case "any":
          return "any character";
        case "end":
          return "end of input";
        case "other":
          return expectation.description;
      }
    }

    function describeExpected(expected1: Expectation[]) {
      const descriptions = expected1.map(describeExpectation);
      let i: number;
      let j: number;

      descriptions.sort();

      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }

      switch (descriptions.length) {
        case 1:
          return descriptions[0];

        case 2:
          return descriptions[0] + " or " + descriptions[1];

        default:
          return descriptions.slice(0, -1).join(", ")
            + ", or "
            + descriptions[descriptions.length - 1];
      }
    }

    function describeFound(found1: string | null) {
      return found1 ? "\"" + literalEscape(found1) + "\"" : "end of input";
    }

    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  }

  public message: string;
  public expected: Expectation[];
  public found: string | null;
  public location: IFileRange;
  public name: string;

  constructor(message: string, expected: Expectation[], found: string | null, location: IFileRange) {
    super();
    this.message = message;
    this.expected = expected;
    this.found = found;
    this.location = location;
    this.name = "SyntaxError";

    if (typeof (Object as any).setPrototypeOf === "function") {
      (Object as any).setPrototypeOf(this, SyntaxError.prototype);
    } else {
      (this as any).__proto__ = SyntaxError.prototype;
    }
    if (typeof (Error as any).captureStackTrace === "function") {
      (Error as any).captureStackTrace(this, SyntaxError);
    }
  }

  format(sources: { grammarSource?: string; text: string }[]): string {
    let str = 'Error: ' + this.message;
    if (this.location) {
      let src: string[] | null = null;
      let k;
      for (k = 0; k < sources.length; k++) {
        if (sources[k].grammarSource === this.location.source) {
          src = sources[k].text.split(/\r\n|\n|\r/g);
          break;
        }
      }
      let s = this.location.start;
      let loc = this.location.source + ':' + s.line + ':' + s.column;
      if (src) {
        let e = this.location.end;
        let filler = peg$padEnd('', s.line.toString().length, ' ');
        let line = src[s.line - 1];
        let last = s.line === e.line ? e.column : line.length + 1;
        str += '\n --> ' + loc + '\n' + filler + ' |\n' + s.line + ' | ' + line + '\n' + filler + ' | ' +
          peg$padEnd('', s.column - 1, ' ') +
          peg$padEnd('', last - s.column, '^');
      } else {
        str += '\n at ' + loc;
      }
    }
    return str;
  }
}

function peg$parse(input: string, options?: IParseOptions) {
  options = options !== undefined ? options : {};

  const peg$FAILED: Readonly<any> = {};
  const peg$source = options.grammarSource;

  const peg$startRuleFunctions: {[id: string]: any} = { StartRule: peg$parseStartRule };
  let peg$startRuleFunction: () => any = peg$parseStartRule;

  const peg$c0 = "table";
  const peg$c1 = peg$literalExpectation("table", true);
  const peg$c2 = function(table: any): any { return { table }; };
  const peg$c3 = function(parameters: any): any { return wrap(parameters, 'parameters'); };
  const peg$c4 = function(conditions: any): any { return wrap(conditions, 'conditions'); };
  const peg$c5 = function(rows: any): any { return wrap(rows, 'rows'); };
  const peg$c6 = function(scope: any): any { return wrap(scope, 'scope'); };
  const peg$c7 = function(templates: any): any { return wrap(templates, 'templates'); };
  const peg$c8 = function(sources: any): any { return wrap(sources, 'sources') };
  const peg$c9 = function(table: any): any { return processTableContent(table); };
  const peg$c10 = "header";
  const peg$c11 = peg$literalExpectation("header", true);
  const peg$c12 = function(columns: any): any { return { columns }; };
  const peg$c13 = "column";
  const peg$c14 = peg$literalExpectation("column", true);
  const peg$c15 = function(): any { return {}; };
  const peg$c16 = function(column: any): any { return mergeDeep(column); };
  const peg$c17 = "text";
  const peg$c18 = peg$literalExpectation("text", true);
  const peg$c19 = function(text: any): any { return { text }; };
  const peg$c20 = "width";
  const peg$c21 = peg$literalExpectation("width", true);
  const peg$c22 = function(width: any): any { return { width }; };
  const peg$c23 = "row";
  const peg$c24 = peg$literalExpectation("row", true);
  const peg$c25 = function(cells: any): any { return wrap(cells, 'cells'); };
  const peg$c26 = function(row: any): any { return processTableRow(row); };
  const peg$c27 = "cell";
  const peg$c28 = peg$literalExpectation("cell", true);
  const peg$c29 = function(cell: any): any { return processTableCell(cell); };
  const peg$c30 = function(condition: any, parameters: any): any { return { condition, parameters: mergeParameters(parameters) }; };
  const peg$c31 = function(ifExpression: any): any { return ifExpression; };
  const peg$c32 = function(name: any): any { return wrap(name, 'name'); };
  const peg$c33 = function(args: any): any { return wrap(args, 'args'); };
  const peg$c34 = function(template: any): any { return processTableCellTemplate(template); };
  const peg$c35 = "grid";
  const peg$c36 = peg$literalExpectation("grid", true);
  const peg$c37 = function(grid: any): any { return { grid }; };
  const peg$c38 = function(grid: any): any { return processGridContent(grid); };
  const peg$c39 = "columns";
  const peg$c40 = peg$literalExpectation("columns", true);
  const peg$c41 = function(text: any): any { return processGridColumnsCount(text); };
  const peg$c42 = function(cell: any): any { return processGridCell(cell); };
  const peg$c43 = function(template: any): any { return processGridCellTemplate(template); };
  const peg$c44 = "if";
  const peg$c45 = peg$literalExpectation("if", true);
  const peg$c46 = function(key: any): any { return key; };
  const peg$c47 = "templates";
  const peg$c48 = peg$literalExpectation("templates", true);
  const peg$c49 = "template";
  const peg$c50 = peg$literalExpectation("template", true);
  const peg$c51 = "source";
  const peg$c52 = peg$literalExpectation("source", true);
  const peg$c53 = function(name: any, url: any): any { return processSource(name, url); };
  const peg$c54 = function(url: any, name: any): any { return processSource(name, url); };
  const peg$c55 = "url";
  const peg$c56 = peg$literalExpectation("url", true);
  const peg$c57 = function(url: any): any { return processRequiredValue(url, 'Source URL'); };
  const peg$c58 = "name";
  const peg$c59 = peg$literalExpectation("name", true);
  const peg$c60 = function(name: any): any { return processRequiredValue(name, 'Source name'); };
  const peg$c61 = "use-template";
  const peg$c62 = peg$literalExpectation("use-template", true);
  const peg$c63 = function(template: any): any { return template; };
  const peg$c64 = "use_template";
  const peg$c65 = peg$literalExpectation("use_template", true);
  const peg$c66 = function(name: any, args: any): any { return processTemplateUseContent(name, args); };
  const peg$c67 = function(args: any, name: any): any { return processTemplateUseContent(name, args); };
  const peg$c68 = function(name: any): any { return processRequiredValue(name, 'Template name'); };
  const peg$c69 = "parameters";
  const peg$c70 = peg$literalExpectation("parameters", true);
  const peg$c71 = function(args: any): any { return processTemplateArguments(args); };
  const peg$c72 = "parameter";
  const peg$c73 = peg$literalExpectation("parameter", true);
  const peg$c74 = function(argument: any): any { return processTemplateArgument(argument, 2); };
  const peg$c75 = function(argument: any): any { return processTemplateArgument(argument, 1); };
  const peg$c76 = "scope";
  const peg$c77 = peg$literalExpectation("scope", true);
  const peg$c78 = function(scope: any): any { return processScriptScope(scope); };
  const peg$c79 = "condition";
  const peg$c80 = peg$literalExpectation("condition", true);
  const peg$c81 = function(condition: any): any { return processConditionExpression(condition); };
  const peg$c82 = "style";
  const peg$c83 = peg$literalExpectation("style", true);
  const peg$c84 = function(styles: any): any { return processStyle(styles); };
  const peg$c85 = function(startTag: any, content: any, endTag: any): any { return processStyleItem(startTag, content, endTag); };
  const peg$c86 = function(startTag: any): any { return processEmptyStyleItem(startTag); };
  const peg$c87 = "tooltip";
  const peg$c88 = peg$literalExpectation("tooltip", true);
  const peg$c89 = function(tooltip: any): any { return processTooltip(tooltip); };
  const peg$c90 = function(value: any): any { return processDisplayValue(value); };
  const peg$c91 = function(parameters: any): any { return processFormattedText(parameters); };
  const peg$c92 = "format";
  const peg$c93 = peg$literalExpectation("format", true);
  const peg$c94 = function(format: any): any { return processFormat(format); };
  const peg$c95 = "formula";
  const peg$c96 = peg$literalExpectation("formula", true);
  const peg$c97 = function(formula: any): any { return processFormula(formula); };
  const peg$c98 = function(text: any): any { return processGridColumn(text); };
  const peg$c99 = "mark";
  const peg$c100 = peg$literalExpectation("mark", true);
  const peg$c101 = function(parameters: any): any { return processMark(parameters); };
  const peg$c102 = peg$otherExpectation("\"<\"");
  const peg$c103 = "<";
  const peg$c104 = peg$literalExpectation("<", false);
  const peg$c105 = peg$otherExpectation("\">\"");
  const peg$c106 = ">";
  const peg$c107 = peg$literalExpectation(">", false);
  const peg$c108 = peg$otherExpectation("\"/\"");
  const peg$c109 = "/";
  const peg$c110 = peg$literalExpectation("/", false);
  const peg$c111 = peg$otherExpectation("<![CDATA[");
  const peg$c112 = "<![CDATA[";
  const peg$c113 = peg$literalExpectation("<![CDATA[", false);
  const peg$c114 = peg$otherExpectation("]]>");
  const peg$c115 = "]]>";
  const peg$c116 = peg$literalExpectation("]]>", false);
  const peg$c117 = peg$otherExpectation("\"Tag name\"");
  const peg$c118 = /^[a-zA-Z]/;
  const peg$c119 = peg$classExpectation([["a", "z"], ["A", "Z"]], false, false);
  const peg$c120 = /^[\-_]/;
  const peg$c121 = peg$classExpectation(["-", "_"], false, false);
  const peg$c122 = /^[a-zA-Z0-9]/;
  const peg$c123 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"]], false, false);
  const peg$c124 = function(): any { return text(); };
  const peg$c125 = peg$otherExpectation("\"Tag value\"");
  const peg$c126 = peg$anyExpectation();
  const peg$c127 = function(): any {
      return text()
          .replaceAll(/(&apos;)|(&#39;)/g, `'`)
          .replaceAll(/(&quot;)|(&#34;)/g, `"`)
          .replaceAll(/(&gt;)|(&#62;)/g, `>`)
          .replaceAll(/(&lt;)|(&#60;)/g, `<`)
          .replaceAll(/(&amp;)|(&#38;)/g, `&`);
  };
  const peg$c128 = peg$otherExpectation("\"Tag number value\"");
  const peg$c129 = function(): any {
      const value = text();
      if (!value) {
        return undefined;
      }

      const num = parseFloat(value);

      return isNaN(num) || !isFinite(num) ? undefined : num;
  };
  const peg$c130 = peg$otherExpectation("\"CDATA section\"");
  const peg$c131 = function(): any { return text()?.trim() ?? ''; };
  const peg$c132 = function(text: any): any { return text; };
  const peg$c133 = function(text: any): any { return text.trim() ?? ''; };
  const peg$c134 = peg$otherExpectation("\"Closing tag name\"");
  const peg$c135 = peg$otherExpectation("whitespace");
  const peg$c136 = /^[ \t\n\r]/;
  const peg$c137 = peg$classExpectation([" ", "\t", "\n", "\r"], false, false);

  let peg$currPos = 0;
  let peg$savedPos = 0;
  const peg$posDetailsCache = [{ line: 1, column: 1 }];
  let peg$maxFailPos = 0;
  let peg$maxFailExpected: Expectation[] = [];
  let peg$silentFails = 0;

  let peg$result;

  if (options.startRule !== undefined) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text(): string {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function location(): IFileRange {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description: string, location1?: IFileRange) {
    location1 = location1 !== undefined
      ? location1
      : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location1
    );
  }

  function error(message: string, location1?: IFileRange) {
    location1 = location1 !== undefined
      ? location1
      : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildSimpleError(message, location1);
  }

  function peg$literalExpectation(text1: string, ignoreCase: boolean): ILiteralExpectation {
    return { type: "literal", text: text1, ignoreCase: ignoreCase };
  }

  function peg$classExpectation(parts: IClassParts, inverted: boolean, ignoreCase: boolean): IClassExpectation {
    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
  }

  function peg$anyExpectation(): IAnyExpectation {
    return { type: "any" };
  }

  function peg$endExpectation(): IEndExpectation {
    return { type: "end" };
  }

  function peg$otherExpectation(description: string): IOtherExpectation {
    return { type: "other", description: description };
  }

  function peg$computePosDetails(pos: number) {
    let details = peg$posDetailsCache[pos];
    let p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line: details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;

      return details;
    }
  }

  function peg$computeLocation(startPos: number, endPos: number): IFileRange {
    const startPosDetails = peg$computePosDetails(startPos);
    const endPosDetails = peg$computePosDetails(endPos);

    return {
      source: peg$source,
      start: {
        offset: startPos,
        line: startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line: endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$fail(expected1: Expectation) {
    if (peg$currPos < peg$maxFailPos) { return; }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected1);
  }

  function peg$buildSimpleError(message: string, location1: IFileRange) {
    return new SyntaxError(message, [], "", location1);
  }

  function peg$buildStructuredError(expected1: Expectation[], found: string | null, location1: IFileRange) {
    return new SyntaxError(
      SyntaxError.buildMessage(expected1, found),
      expected1,
      found,
      location1
    );
  }

  function peg$parseStartRule(): any {
    let s0;

    s0 = peg$parseGrid();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parseTable();
    }

    return s0;
  }

  function peg$parseTable(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c0) {
        s3 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c1); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseTableContent();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseLeftArrow();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseBackSlash();
          if (s5 as any !== peg$FAILED) {
            if (input.substr(peg$currPos, 5).toLowerCase() === peg$c0) {
              s6 = input.substr(peg$currPos, 5);
              peg$currPos += 5;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c1); }
            }
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseRightArrow();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c2(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseTableContent(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$currPos;
    s3 = peg$parseTableHeader();
    if (s3 as any !== peg$FAILED) {
      peg$savedPos = s2;
      s3 = peg$c3(s3);
    }
    s2 = s3;
    if (s2 as any === peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$parseIfTableExpression();
      if (s3 as any !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c4(s3);
      }
      s2 = s3;
      if (s2 as any === peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$parseTableRow();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c5(s3);
        }
        s2 = s3;
        if (s2 as any === peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parseScriptScope();
          if (s3 as any !== peg$FAILED) {
            peg$savedPos = s2;
            s3 = peg$c6(s3);
          }
          s2 = s3;
          if (s2 as any === peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseTableCellTemplate();
            if (s3 as any !== peg$FAILED) {
              peg$savedPos = s2;
              s3 = peg$c7(s3);
            }
            s2 = s3;
            if (s2 as any === peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$parseSource();
              if (s3 as any !== peg$FAILED) {
                peg$savedPos = s2;
                s3 = peg$c8(s3);
              }
              s2 = s3;
            }
          }
        }
      }
    }
    while (s2 as any !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$currPos;
      s3 = peg$parseTableHeader();
      if (s3 as any !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c3(s3);
      }
      s2 = s3;
      if (s2 as any === peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$parseIfTableExpression();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c4(s3);
        }
        s2 = s3;
        if (s2 as any === peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parseTableRow();
          if (s3 as any !== peg$FAILED) {
            peg$savedPos = s2;
            s3 = peg$c5(s3);
          }
          s2 = s3;
          if (s2 as any === peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseScriptScope();
            if (s3 as any !== peg$FAILED) {
              peg$savedPos = s2;
              s3 = peg$c6(s3);
            }
            s2 = s3;
            if (s2 as any === peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$parseTableCellTemplate();
              if (s3 as any !== peg$FAILED) {
                peg$savedPos = s2;
                s3 = peg$c7(s3);
              }
              s2 = s3;
              if (s2 as any === peg$FAILED) {
                s2 = peg$currPos;
                s3 = peg$parseSource();
                if (s3 as any !== peg$FAILED) {
                  peg$savedPos = s2;
                  s3 = peg$c8(s3);
                }
                s2 = s3;
              }
            }
          }
        }
      }
    }
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c9(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseTableHeader(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c10) {
        s3 = input.substr(peg$currPos, 6);
        peg$currPos += 6;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c11); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseTableHeaderColumn();
      if (s3 as any === peg$FAILED) {
        s3 = peg$parseEmptyTableHeaderColumn();
      }
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseTableHeaderColumn();
        if (s3 as any === peg$FAILED) {
          s3 = peg$parseEmptyTableHeaderColumn();
        }
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseLeftArrow();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseBackSlash();
          if (s5 as any !== peg$FAILED) {
            if (input.substr(peg$currPos, 6).toLowerCase() === peg$c10) {
              s6 = input.substr(peg$currPos, 6);
              peg$currPos += 6;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c11); }
            }
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseRightArrow();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c12(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseEmptyTableHeaderColumn(): any {
    let s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c13) {
        s3 = input.substr(peg$currPos, 6);
        peg$currPos += 6;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c14); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseBackSlash();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseRightArrow();
          if (s5 as any !== peg$FAILED) {
            s2 = [s2, s3, s4, s5];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c15();
    }
    s0 = s1;

    return s0;
  }

  function peg$parseTableHeaderColumn(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c13) {
        s3 = input.substr(peg$currPos, 6);
        peg$currPos += 6;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c14); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseTableHeaderColumnText();
      if (s3 as any === peg$FAILED) {
        s3 = peg$parseTableHeaderColumnWidth();
      }
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseTableHeaderColumnText();
        if (s3 as any === peg$FAILED) {
          s3 = peg$parseTableHeaderColumnWidth();
        }
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseLeftArrow();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseBackSlash();
          if (s5 as any !== peg$FAILED) {
            if (input.substr(peg$currPos, 6).toLowerCase() === peg$c13) {
              s6 = input.substr(peg$currPos, 6);
              peg$currPos += 6;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c14); }
            }
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseRightArrow();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c16(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseTableHeaderColumnText(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c17) {
        s3 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c18); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseTagValue();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseLeftArrow();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseBackSlash();
          if (s5 as any !== peg$FAILED) {
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c17) {
              s6 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c18); }
            }
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseRightArrow();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c19(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseTableHeaderColumnWidth(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c20) {
        s3 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c21); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseTagNumberValue();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseLeftArrow();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseBackSlash();
          if (s5 as any !== peg$FAILED) {
            if (input.substr(peg$currPos, 5).toLowerCase() === peg$c20) {
              s6 = input.substr(peg$currPos, 5);
              peg$currPos += 5;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c21); }
            }
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseRightArrow();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c22(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseTableRow(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 3).toLowerCase() === peg$c23) {
        s3 = input.substr(peg$currPos, 3);
        peg$currPos += 3;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c24); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parseTableRow();
      if (s4 as any !== peg$FAILED) {
        peg$savedPos = s3;
        s4 = peg$c5(s4);
      }
      s3 = s4;
      if (s3 as any === peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseStyle();
        if (s4 as any !== peg$FAILED) {
          peg$savedPos = s3;
          s4 = peg$c3(s4);
        }
        s3 = s4;
        if (s3 as any === peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parseIfTableRowExpression();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s3;
            s4 = peg$c4(s4);
          }
          s3 = s4;
          if (s3 as any === peg$FAILED) {
            s3 = peg$currPos;
            s4 = peg$parseTableCell();
            if (s4 as any === peg$FAILED) {
              s4 = peg$parseEmptyTableCell();
            }
            if (s4 as any !== peg$FAILED) {
              peg$savedPos = s3;
              s4 = peg$c25(s4);
            }
            s3 = s4;
          }
        }
      }
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parseTableRow();
        if (s4 as any !== peg$FAILED) {
          peg$savedPos = s3;
          s4 = peg$c5(s4);
        }
        s3 = s4;
        if (s3 as any === peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parseStyle();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s3;
            s4 = peg$c3(s4);
          }
          s3 = s4;
          if (s3 as any === peg$FAILED) {
            s3 = peg$currPos;
            s4 = peg$parseIfTableRowExpression();
            if (s4 as any !== peg$FAILED) {
              peg$savedPos = s3;
              s4 = peg$c4(s4);
            }
            s3 = s4;
            if (s3 as any === peg$FAILED) {
              s3 = peg$currPos;
              s4 = peg$parseTableCell();
              if (s4 as any === peg$FAILED) {
                s4 = peg$parseEmptyTableCell();
              }
              if (s4 as any !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c25(s4);
              }
              s3 = s4;
            }
          }
        }
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseLeftArrow();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseBackSlash();
          if (s5 as any !== peg$FAILED) {
            if (input.substr(peg$currPos, 3).toLowerCase() === peg$c23) {
              s6 = input.substr(peg$currPos, 3);
              peg$currPos += 3;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c24); }
            }
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseRightArrow();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c26(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseEmptyTableCell(): any {
    let s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c27) {
        s3 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c28); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseBackSlash();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseRightArrow();
          if (s5 as any !== peg$FAILED) {
            s2 = [s2, s3, s4, s5];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c15();
    }
    s0 = s1;

    return s0;
  }

  function peg$parseTableCell(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c27) {
        s3 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c28); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parseTableCellParameters();
      if (s4 as any !== peg$FAILED) {
        peg$savedPos = s3;
        s4 = peg$c3(s4);
      }
      s3 = s4;
      if (s3 as any === peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseIfTableCellExpression();
        if (s4 as any !== peg$FAILED) {
          peg$savedPos = s3;
          s4 = peg$c4(s4);
        }
        s3 = s4;
        if (s3 as any === peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parseTemplateUse();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s3;
            s4 = peg$c7(s4);
          }
          s3 = s4;
        }
      }
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parseTableCellParameters();
        if (s4 as any !== peg$FAILED) {
          peg$savedPos = s3;
          s4 = peg$c3(s4);
        }
        s3 = s4;
        if (s3 as any === peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parseIfTableCellExpression();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s3;
            s4 = peg$c4(s4);
          }
          s3 = s4;
          if (s3 as any === peg$FAILED) {
            s3 = peg$currPos;
            s4 = peg$parseTemplateUse();
            if (s4 as any !== peg$FAILED) {
              peg$savedPos = s3;
              s4 = peg$c7(s4);
            }
            s3 = s4;
          }
        }
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseLeftArrow();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseBackSlash();
          if (s5 as any !== peg$FAILED) {
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c27) {
              s6 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c28); }
            }
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseRightArrow();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c29(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseTableCellParameters(): any {
    let s0;

    s0 = peg$parseStyle();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parseTooltip();
      if (s0 as any === peg$FAILED) {
        s0 = peg$parseMark();
        if (s0 as any === peg$FAILED) {
          s0 = peg$parseDisplayValue();
        }
      }
    }

    return s0;
  }

  function peg$parseIfTableCellExpression(): any {
    let s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parseIfExpressionStartTag();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$parseConditionExpression();
      if (s3 as any !== peg$FAILED) {
        s4 = [];
        s5 = peg$parseTableCellParameters();
        while (s5 as any !== peg$FAILED) {
          s4.push(s5);
          s5 = peg$parseTableCellParameters();
        }
        if (s4 as any !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c30(s3, s4);
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseIfExpressionEndTag();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c31(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseIfTableRowExpression(): any {
    let s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parseIfExpressionStartTag();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$parseConditionExpression();
      if (s3 as any !== peg$FAILED) {
        s4 = [];
        s5 = peg$parseStyle();
        while (s5 as any !== peg$FAILED) {
          s4.push(s5);
          s5 = peg$parseStyle();
        }
        if (s4 as any !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c30(s3, s4);
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseIfExpressionEndTag();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c31(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseIfTableExpression(): any {
    let s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parseIfExpressionStartTag();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$parseConditionExpression();
      if (s3 as any !== peg$FAILED) {
        s4 = [];
        s5 = peg$parseTableHeader();
        while (s5 as any !== peg$FAILED) {
          s4.push(s5);
          s5 = peg$parseTableHeader();
        }
        if (s4 as any !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c30(s3, s4);
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseIfExpressionEndTag();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c31(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseTableCellTemplate(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseTemplateStartTag();
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parseTemplateName();
      if (s4 as any !== peg$FAILED) {
        peg$savedPos = s3;
        s4 = peg$c32(s4);
      }
      s3 = s4;
      if (s3 as any === peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseTemplateArguments();
        if (s4 as any !== peg$FAILED) {
          peg$savedPos = s3;
          s4 = peg$c33(s4);
        }
        s3 = s4;
        if (s3 as any === peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parseTableCellParameters();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s3;
            s4 = peg$c3(s4);
          }
          s3 = s4;
          if (s3 as any === peg$FAILED) {
            s3 = peg$currPos;
            s4 = peg$parseIfTableCellExpression();
            if (s4 as any !== peg$FAILED) {
              peg$savedPos = s3;
              s4 = peg$c4(s4);
            }
            s3 = s4;
          }
        }
      }
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parseTemplateName();
        if (s4 as any !== peg$FAILED) {
          peg$savedPos = s3;
          s4 = peg$c32(s4);
        }
        s3 = s4;
        if (s3 as any === peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parseTemplateArguments();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s3;
            s4 = peg$c33(s4);
          }
          s3 = s4;
          if (s3 as any === peg$FAILED) {
            s3 = peg$currPos;
            s4 = peg$parseTableCellParameters();
            if (s4 as any !== peg$FAILED) {
              peg$savedPos = s3;
              s4 = peg$c3(s4);
            }
            s3 = s4;
            if (s3 as any === peg$FAILED) {
              s3 = peg$currPos;
              s4 = peg$parseIfTableCellExpression();
              if (s4 as any !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c4(s4);
              }
              s3 = s4;
            }
          }
        }
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseTemplateEndTag();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c34(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseGrid(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c35) {
        s3 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c36); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseGridContent();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseLeftArrow();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseBackSlash();
          if (s5 as any !== peg$FAILED) {
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c35) {
              s6 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c36); }
            }
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseRightArrow();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c37(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseGridContent(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$currPos;
    s3 = peg$parseGridParameters();
    if (s3 as any !== peg$FAILED) {
      peg$savedPos = s2;
      s3 = peg$c3(s3);
    }
    s2 = s3;
    if (s2 as any === peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$parseIfGridExpression();
      if (s3 as any !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c4(s3);
      }
      s2 = s3;
      if (s2 as any === peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$parseGridCell();
        if (s3 as any === peg$FAILED) {
          s3 = peg$parseEmptyGridCell();
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c25(s3);
        }
        s2 = s3;
        if (s2 as any === peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parseScriptScope();
          if (s3 as any !== peg$FAILED) {
            peg$savedPos = s2;
            s3 = peg$c6(s3);
          }
          s2 = s3;
          if (s2 as any === peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseGridCellTemplate();
            if (s3 as any !== peg$FAILED) {
              peg$savedPos = s2;
              s3 = peg$c7(s3);
            }
            s2 = s3;
            if (s2 as any === peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$parseSource();
              if (s3 as any !== peg$FAILED) {
                peg$savedPos = s2;
                s3 = peg$c8(s3);
              }
              s2 = s3;
            }
          }
        }
      }
    }
    while (s2 as any !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$currPos;
      s3 = peg$parseGridParameters();
      if (s3 as any !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c3(s3);
      }
      s2 = s3;
      if (s2 as any === peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$parseIfGridExpression();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c4(s3);
        }
        s2 = s3;
        if (s2 as any === peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parseGridCell();
          if (s3 as any === peg$FAILED) {
            s3 = peg$parseEmptyGridCell();
          }
          if (s3 as any !== peg$FAILED) {
            peg$savedPos = s2;
            s3 = peg$c25(s3);
          }
          s2 = s3;
          if (s2 as any === peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseScriptScope();
            if (s3 as any !== peg$FAILED) {
              peg$savedPos = s2;
              s3 = peg$c6(s3);
            }
            s2 = s3;
            if (s2 as any === peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$parseGridCellTemplate();
              if (s3 as any !== peg$FAILED) {
                peg$savedPos = s2;
                s3 = peg$c7(s3);
              }
              s2 = s3;
              if (s2 as any === peg$FAILED) {
                s2 = peg$currPos;
                s3 = peg$parseSource();
                if (s3 as any !== peg$FAILED) {
                  peg$savedPos = s2;
                  s3 = peg$c8(s3);
                }
                s2 = s3;
              }
            }
          }
        }
      }
    }
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c38(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseGridColumnsCount(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 7).toLowerCase() === peg$c39) {
        s3 = input.substr(peg$currPos, 7);
        peg$currPos += 7;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c40); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseTagValue();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseLeftArrow();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseBackSlash();
          if (s5 as any !== peg$FAILED) {
            if (input.substr(peg$currPos, 7).toLowerCase() === peg$c39) {
              s6 = input.substr(peg$currPos, 7);
              peg$currPos += 7;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c40); }
            }
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseRightArrow();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c41(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseEmptyGridCell(): any {
    let s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c27) {
        s3 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c28); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseBackSlash();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseRightArrow();
          if (s5 as any !== peg$FAILED) {
            s2 = [s2, s3, s4, s5];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c15();
    }
    s0 = s1;

    return s0;
  }

  function peg$parseGridCell(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c27) {
        s3 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c28); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parseGridCellParameters();
      if (s4 as any !== peg$FAILED) {
        peg$savedPos = s3;
        s4 = peg$c3(s4);
      }
      s3 = s4;
      if (s3 as any === peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseIfGridCellExpression();
        if (s4 as any !== peg$FAILED) {
          peg$savedPos = s3;
          s4 = peg$c4(s4);
        }
        s3 = s4;
        if (s3 as any === peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parseTemplateUse();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s3;
            s4 = peg$c7(s4);
          }
          s3 = s4;
        }
      }
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parseGridCellParameters();
        if (s4 as any !== peg$FAILED) {
          peg$savedPos = s3;
          s4 = peg$c3(s4);
        }
        s3 = s4;
        if (s3 as any === peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parseIfGridCellExpression();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s3;
            s4 = peg$c4(s4);
          }
          s3 = s4;
          if (s3 as any === peg$FAILED) {
            s3 = peg$currPos;
            s4 = peg$parseTemplateUse();
            if (s4 as any !== peg$FAILED) {
              peg$savedPos = s3;
              s4 = peg$c7(s4);
            }
            s3 = s4;
          }
        }
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseLeftArrow();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseBackSlash();
          if (s5 as any !== peg$FAILED) {
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c27) {
              s6 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c28); }
            }
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseRightArrow();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c42(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseGridParameters(): any {
    let s0;

    s0 = peg$parseStyle();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parseGridColumnsCount();
    }

    return s0;
  }

  function peg$parseGridCellParameters(): any {
    let s0;

    s0 = peg$parseStyle();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parseTooltip();
      if (s0 as any === peg$FAILED) {
        s0 = peg$parseMark();
        if (s0 as any === peg$FAILED) {
          s0 = peg$parseDisplayValue();
          if (s0 as any === peg$FAILED) {
            s0 = peg$parseGridColumn();
          }
        }
      }
    }

    return s0;
  }

  function peg$parseIfGridCellExpression(): any {
    let s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parseIfExpressionStartTag();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$parseConditionExpression();
      if (s3 as any !== peg$FAILED) {
        s4 = [];
        s5 = peg$parseGridCellParameters();
        while (s5 as any !== peg$FAILED) {
          s4.push(s5);
          s5 = peg$parseGridCellParameters();
        }
        if (s4 as any !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c30(s3, s4);
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseIfExpressionEndTag();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c31(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseIfGridExpression(): any {
    let s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parseIfExpressionStartTag();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$parseConditionExpression();
      if (s3 as any !== peg$FAILED) {
        s4 = [];
        s5 = peg$parseGridParameters();
        while (s5 as any !== peg$FAILED) {
          s4.push(s5);
          s5 = peg$parseGridParameters();
        }
        if (s4 as any !== peg$FAILED) {
          peg$savedPos = s2;
          s3 = peg$c30(s3, s4);
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseIfExpressionEndTag();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c31(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseGridCellTemplate(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseTemplateStartTag();
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parseTemplateName();
      if (s4 as any !== peg$FAILED) {
        peg$savedPos = s3;
        s4 = peg$c32(s4);
      }
      s3 = s4;
      if (s3 as any === peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseTemplateArguments();
        if (s4 as any !== peg$FAILED) {
          peg$savedPos = s3;
          s4 = peg$c33(s4);
        }
        s3 = s4;
        if (s3 as any === peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parseGridCellParameters();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s3;
            s4 = peg$c3(s4);
          }
          s3 = s4;
          if (s3 as any === peg$FAILED) {
            s3 = peg$currPos;
            s4 = peg$parseIfGridCellExpression();
            if (s4 as any !== peg$FAILED) {
              peg$savedPos = s3;
              s4 = peg$c4(s4);
            }
            s3 = s4;
          }
        }
      }
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parseTemplateName();
        if (s4 as any !== peg$FAILED) {
          peg$savedPos = s3;
          s4 = peg$c32(s4);
        }
        s3 = s4;
        if (s3 as any === peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parseTemplateArguments();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s3;
            s4 = peg$c33(s4);
          }
          s3 = s4;
          if (s3 as any === peg$FAILED) {
            s3 = peg$currPos;
            s4 = peg$parseGridCellParameters();
            if (s4 as any !== peg$FAILED) {
              peg$savedPos = s3;
              s4 = peg$c3(s4);
            }
            s3 = s4;
            if (s3 as any === peg$FAILED) {
              s3 = peg$currPos;
              s4 = peg$parseIfGridCellExpression();
              if (s4 as any !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c4(s4);
              }
              s3 = s4;
            }
          }
        }
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseTemplateEndTag();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c43(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseIfExpressionStartTag(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseLeftArrow();
    if (s1 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 2).toLowerCase() === peg$c44) {
        s2 = input.substr(peg$currPos, 2);
        peg$currPos += 2;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c45); }
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseRightArrow();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c46(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseIfExpressionEndTag(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseLeftArrow();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseBackSlash();
      if (s2 as any !== peg$FAILED) {
        if (input.substr(peg$currPos, 2).toLowerCase() === peg$c44) {
          s3 = input.substr(peg$currPos, 2);
          peg$currPos += 2;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c45); }
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseRightArrow();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c46(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseTemplatesStartTag(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseLeftArrow();
    if (s1 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 9).toLowerCase() === peg$c47) {
        s2 = input.substr(peg$currPos, 9);
        peg$currPos += 9;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c48); }
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseRightArrow();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c46(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseTemplatesEndTag(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseLeftArrow();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseBackSlash();
      if (s2 as any !== peg$FAILED) {
        if (input.substr(peg$currPos, 9).toLowerCase() === peg$c47) {
          s3 = input.substr(peg$currPos, 9);
          peg$currPos += 9;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c48); }
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseRightArrow();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c46(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseTemplateStartTag(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseLeftArrow();
    if (s1 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 8).toLowerCase() === peg$c49) {
        s2 = input.substr(peg$currPos, 8);
        peg$currPos += 8;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c50); }
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseRightArrow();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c46(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseTemplateEndTag(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseLeftArrow();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseBackSlash();
      if (s2 as any !== peg$FAILED) {
        if (input.substr(peg$currPos, 8).toLowerCase() === peg$c49) {
          s3 = input.substr(peg$currPos, 8);
          peg$currPos += 8;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c50); }
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseRightArrow();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c46(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseSource(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7, s8;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c51) {
        s3 = input.substr(peg$currPos, 6);
        peg$currPos += 6;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c52); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseSourceName();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseSourceUrl();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$currPos;
          s5 = peg$parseLeftArrow();
          if (s5 as any !== peg$FAILED) {
            s6 = peg$parseBackSlash();
            if (s6 as any !== peg$FAILED) {
              if (input.substr(peg$currPos, 6).toLowerCase() === peg$c51) {
                s7 = input.substr(peg$currPos, 6);
                peg$currPos += 6;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c52); }
              }
              if (s7 as any !== peg$FAILED) {
                s8 = peg$parseRightArrow();
                if (s8 as any !== peg$FAILED) {
                  s5 = [s5, s6, s7, s8];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c53(s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 as any === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parseLeftArrow();
      if (s2 as any !== peg$FAILED) {
        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c51) {
          s3 = input.substr(peg$currPos, 6);
          peg$currPos += 6;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c52); }
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseRightArrow();
          if (s4 as any !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 as any !== peg$FAILED) {
        s2 = peg$parseSourceUrl();
        if (s2 as any !== peg$FAILED) {
          s3 = peg$parseSourceName();
          if (s3 as any !== peg$FAILED) {
            s4 = peg$currPos;
            s5 = peg$parseLeftArrow();
            if (s5 as any !== peg$FAILED) {
              s6 = peg$parseBackSlash();
              if (s6 as any !== peg$FAILED) {
                if (input.substr(peg$currPos, 6).toLowerCase() === peg$c51) {
                  s7 = input.substr(peg$currPos, 6);
                  peg$currPos += 6;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c52); }
                }
                if (s7 as any !== peg$FAILED) {
                  s8 = peg$parseRightArrow();
                  if (s8 as any !== peg$FAILED) {
                    s5 = [s5, s6, s7, s8];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 as any !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c54(s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseSourceUrl(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 3).toLowerCase() === peg$c55) {
        s3 = input.substr(peg$currPos, 3);
        peg$currPos += 3;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c56); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseTagTextContent();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseLeftArrow();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseBackSlash();
          if (s5 as any !== peg$FAILED) {
            if (input.substr(peg$currPos, 3).toLowerCase() === peg$c55) {
              s6 = input.substr(peg$currPos, 3);
              peg$currPos += 3;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c56); }
            }
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseRightArrow();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c57(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseSourceName(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c58) {
        s3 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c59); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseTagTextContent();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseLeftArrow();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseBackSlash();
          if (s5 as any !== peg$FAILED) {
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c58) {
              s6 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c59); }
            }
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseRightArrow();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c60(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseTemplateUse(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 12).toLowerCase() === peg$c61) {
        s3 = input.substr(peg$currPos, 12);
        peg$currPos += 12;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c62); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseTemplateUseContent();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseLeftArrow();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseBackSlash();
          if (s5 as any !== peg$FAILED) {
            if (input.substr(peg$currPos, 12).toLowerCase() === peg$c61) {
              s6 = input.substr(peg$currPos, 12);
              peg$currPos += 12;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c62); }
            }
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseRightArrow();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c63(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 as any === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parseLeftArrow();
      if (s2 as any !== peg$FAILED) {
        if (input.substr(peg$currPos, 12).toLowerCase() === peg$c64) {
          s3 = input.substr(peg$currPos, 12);
          peg$currPos += 12;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c65); }
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseRightArrow();
          if (s4 as any !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 as any !== peg$FAILED) {
        s2 = peg$parseTemplateUseContent();
        if (s2 as any !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parseLeftArrow();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parseBackSlash();
            if (s5 as any !== peg$FAILED) {
              if (input.substr(peg$currPos, 12).toLowerCase() === peg$c64) {
                s6 = input.substr(peg$currPos, 12);
                peg$currPos += 12;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c65); }
              }
              if (s6 as any !== peg$FAILED) {
                s7 = peg$parseRightArrow();
                if (s7 as any !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c63(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseTemplateUseContent(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseTemplateName();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseTemplateUseArguments();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c66(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 as any === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseTemplateUseArguments();
      if (s1 as any !== peg$FAILED) {
        s2 = peg$parseTemplateName();
        if (s2 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c67(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseTemplateName(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c58) {
        s3 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c59); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseTagTextContent();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseLeftArrow();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseBackSlash();
          if (s5 as any !== peg$FAILED) {
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c58) {
              s6 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c59); }
            }
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseRightArrow();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c68(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseTemplateUseArguments(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 10).toLowerCase() === peg$c69) {
        s3 = input.substr(peg$currPos, 10);
        peg$currPos += 10;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c70); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseTemplateUseArgument();
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseTemplateUseArgument();
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseLeftArrow();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseBackSlash();
          if (s5 as any !== peg$FAILED) {
            if (input.substr(peg$currPos, 10).toLowerCase() === peg$c69) {
              s6 = input.substr(peg$currPos, 10);
              peg$currPos += 10;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c70); }
            }
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseRightArrow();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c71(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseTemplateUseArgument(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 9).toLowerCase() === peg$c72) {
        s3 = input.substr(peg$currPos, 9);
        peg$currPos += 9;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c73); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseTagTextContent();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseLeftArrow();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseBackSlash();
          if (s5 as any !== peg$FAILED) {
            if (input.substr(peg$currPos, 9).toLowerCase() === peg$c72) {
              s6 = input.substr(peg$currPos, 9);
              peg$currPos += 9;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c73); }
            }
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseRightArrow();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c74(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseTemplateArguments(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 10).toLowerCase() === peg$c69) {
        s3 = input.substr(peg$currPos, 10);
        peg$currPos += 10;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c70); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseTemplateArgument();
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseTemplateArgument();
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseLeftArrow();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseBackSlash();
          if (s5 as any !== peg$FAILED) {
            if (input.substr(peg$currPos, 10).toLowerCase() === peg$c69) {
              s6 = input.substr(peg$currPos, 10);
              peg$currPos += 10;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c70); }
            }
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseRightArrow();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c71(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseTemplateArgument(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 9).toLowerCase() === peg$c72) {
        s3 = input.substr(peg$currPos, 9);
        peg$currPos += 9;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c73); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseTagTextContent();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseLeftArrow();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseBackSlash();
          if (s5 as any !== peg$FAILED) {
            if (input.substr(peg$currPos, 9).toLowerCase() === peg$c72) {
              s6 = input.substr(peg$currPos, 9);
              peg$currPos += 9;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c73); }
            }
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseRightArrow();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c75(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseScriptScope(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c76) {
        s3 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c77); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseTagTextContent();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseLeftArrow();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseBackSlash();
          if (s5 as any !== peg$FAILED) {
            if (input.substr(peg$currPos, 5).toLowerCase() === peg$c76) {
              s6 = input.substr(peg$currPos, 5);
              peg$currPos += 5;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c77); }
            }
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseRightArrow();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c78(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseConditionExpression(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 9).toLowerCase() === peg$c79) {
        s3 = input.substr(peg$currPos, 9);
        peg$currPos += 9;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c80); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseTagTextContent();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseLeftArrow();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseBackSlash();
          if (s5 as any !== peg$FAILED) {
            if (input.substr(peg$currPos, 9).toLowerCase() === peg$c79) {
              s6 = input.substr(peg$currPos, 9);
              peg$currPos += 9;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c80); }
            }
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseRightArrow();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c81(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseStyle(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c82) {
        s3 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c83); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseStyleItem();
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseStyleItem();
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseLeftArrow();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseBackSlash();
          if (s5 as any !== peg$FAILED) {
            if (input.substr(peg$currPos, 5).toLowerCase() === peg$c82) {
              s6 = input.substr(peg$currPos, 5);
              peg$currPos += 5;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c83); }
            }
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseRightArrow();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c84(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseStyleItem(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      s3 = peg$parseTagName();
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          peg$savedPos = s1;
          s2 = peg$c46(s3);
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseTagTextContent();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseEndTag();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c85(s1, s2, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 as any === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseLeftArrow();
      if (s1 as any !== peg$FAILED) {
        s2 = peg$parseTagName();
        if (s2 as any !== peg$FAILED) {
          s3 = peg$parseBackSlash();
          if (s3 as any !== peg$FAILED) {
            s4 = peg$parseRightArrow();
            if (s4 as any !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c86(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseTooltip(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 7).toLowerCase() === peg$c87) {
        s3 = input.substr(peg$currPos, 7);
        peg$currPos += 7;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c88); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseTagTextContent();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseLeftArrow();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseBackSlash();
          if (s5 as any !== peg$FAILED) {
            if (input.substr(peg$currPos, 7).toLowerCase() === peg$c87) {
              s6 = input.substr(peg$currPos, 7);
              peg$currPos += 7;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c88); }
            }
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseRightArrow();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c89(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseDisplayValue(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c17) {
        s3 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c18); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseFormattedText();
      if (s2 as any === peg$FAILED) {
        s2 = peg$parseTagTextContent();
      }
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseLeftArrow();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseBackSlash();
          if (s5 as any !== peg$FAILED) {
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c17) {
              s6 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c18); }
            }
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseRightArrow();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c90(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseFormattedText(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseFormat();
    if (s2 as any !== peg$FAILED) {
      s3 = peg$parseFormula();
      if (s3 as any !== peg$FAILED) {
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any === peg$FAILED) {
      s1 = peg$currPos;
      s2 = peg$parseFormula();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseFormat();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    }
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c91(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseFormat(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c92) {
        s3 = input.substr(peg$currPos, 6);
        peg$currPos += 6;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c93); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseTagTextContent();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseLeftArrow();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseBackSlash();
          if (s5 as any !== peg$FAILED) {
            if (input.substr(peg$currPos, 6).toLowerCase() === peg$c92) {
              s6 = input.substr(peg$currPos, 6);
              peg$currPos += 6;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c93); }
            }
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseRightArrow();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c94(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseFormula(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 7).toLowerCase() === peg$c95) {
        s3 = input.substr(peg$currPos, 7);
        peg$currPos += 7;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c96); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseTagTextContent();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseLeftArrow();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseBackSlash();
          if (s5 as any !== peg$FAILED) {
            if (input.substr(peg$currPos, 7).toLowerCase() === peg$c95) {
              s6 = input.substr(peg$currPos, 7);
              peg$currPos += 7;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c96); }
            }
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseRightArrow();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c97(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseGridColumn(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c13) {
        s3 = input.substr(peg$currPos, 6);
        peg$currPos += 6;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c14); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseTagTextContent();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseLeftArrow();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseBackSlash();
          if (s5 as any !== peg$FAILED) {
            if (input.substr(peg$currPos, 6).toLowerCase() === peg$c13) {
              s6 = input.substr(peg$currPos, 6);
              peg$currPos += 6;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c14); }
            }
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseRightArrow();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c98(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseMark(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseLeftArrow();
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c99) {
        s3 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c100); }
      }
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseRightArrow();
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseStyle();
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseStyle();
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseLeftArrow();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseBackSlash();
          if (s5 as any !== peg$FAILED) {
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c99) {
              s6 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c100); }
            }
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseRightArrow();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c101(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseLeftArrow(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 as any !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 60) {
        s2 = peg$c103;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c104); }
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 as any !== peg$FAILED) {
          s1 = [s1, s2, s3];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c102); }
    }

    return s0;
  }

  function peg$parseRightArrow(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 as any !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 62) {
        s2 = peg$c106;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c107); }
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 as any !== peg$FAILED) {
          s1 = [s1, s2, s3];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c105); }
    }

    return s0;
  }

  function peg$parseBackSlash(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 as any !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 47) {
        s2 = peg$c109;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c110); }
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 as any !== peg$FAILED) {
          s1 = [s1, s2, s3];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c108); }
    }

    return s0;
  }

  function peg$parseCDataStart(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 9) === peg$c112) {
        s2 = peg$c112;
        peg$currPos += 9;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c113); }
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 as any !== peg$FAILED) {
          s1 = [s1, s2, s3];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c111); }
    }

    return s0;
  }

  function peg$parseCDataEnd(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 3) === peg$c115) {
        s2 = peg$c115;
        peg$currPos += 3;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c116); }
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 as any !== peg$FAILED) {
          s1 = [s1, s2, s3];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c114); }
    }

    return s0;
  }

  function peg$parseTagName(): any {
    let s0, s1, s2, s3, s4, s5, s6;

    peg$silentFails++;
    s0 = peg$currPos;
    if (peg$c118.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c119); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      if (peg$c120.test(input.charAt(peg$currPos))) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c121); }
      }
      if (s4 as any === peg$FAILED) {
        s4 = null;
      }
      if (s4 as any !== peg$FAILED) {
        s5 = [];
        if (peg$c122.test(input.charAt(peg$currPos))) {
          s6 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s6 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c123); }
        }
        if (s6 as any !== peg$FAILED) {
          while (s6 as any !== peg$FAILED) {
            s5.push(s6);
            if (peg$c122.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c123); }
            }
          }
        } else {
          s5 = peg$FAILED;
        }
        if (s5 as any !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        if (peg$c120.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c121); }
        }
        if (s4 as any === peg$FAILED) {
          s4 = null;
        }
        if (s4 as any !== peg$FAILED) {
          s5 = [];
          if (peg$c122.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c123); }
          }
          if (s6 as any !== peg$FAILED) {
            while (s6 as any !== peg$FAILED) {
              s5.push(s6);
              if (peg$c122.test(input.charAt(peg$currPos))) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c123); }
              }
            }
          } else {
            s5 = peg$FAILED;
          }
          if (s5 as any !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c124();
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c117); }
    }

    return s0;
  }

  function peg$parseTagValue(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$currPos;
    s3 = peg$currPos;
    peg$silentFails++;
    s4 = peg$parseLeftArrow();
    peg$silentFails--;
    if (s4 as any === peg$FAILED) {
      s3 = undefined;
    } else {
      peg$currPos = s3;
      s3 = peg$FAILED;
    }
    if (s3 as any !== peg$FAILED) {
      if (input.length > peg$currPos) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c126); }
      }
      if (s4 as any !== peg$FAILED) {
        s3 = [s3, s4];
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    while (s2 as any !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$currPos;
      s3 = peg$currPos;
      peg$silentFails++;
      s4 = peg$parseLeftArrow();
      peg$silentFails--;
      if (s4 as any === peg$FAILED) {
        s3 = undefined;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 as any !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c126); }
        }
        if (s4 as any !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    }
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c127();
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c125); }
    }

    return s0;
  }

  function peg$parseTagNumberValue(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$currPos;
    s3 = peg$currPos;
    peg$silentFails++;
    s4 = peg$parseLeftArrow();
    peg$silentFails--;
    if (s4 as any === peg$FAILED) {
      s3 = undefined;
    } else {
      peg$currPos = s3;
      s3 = peg$FAILED;
    }
    if (s3 as any !== peg$FAILED) {
      if (input.length > peg$currPos) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c126); }
      }
      if (s4 as any !== peg$FAILED) {
        s3 = [s3, s4];
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    while (s2 as any !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$currPos;
      s3 = peg$currPos;
      peg$silentFails++;
      s4 = peg$parseLeftArrow();
      peg$silentFails--;
      if (s4 as any === peg$FAILED) {
        s3 = undefined;
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 as any !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c126); }
        }
        if (s4 as any !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    }
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c129();
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c128); }
    }

    return s0;
  }

  function peg$parseCData(): any {
    let s0, s1, s2, s3, s4, s5, s6;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseCDataStart();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = [];
      s4 = peg$currPos;
      s5 = peg$currPos;
      peg$silentFails++;
      s6 = peg$parseCDataEnd();
      peg$silentFails--;
      if (s6 as any === peg$FAILED) {
        s5 = undefined;
      } else {
        peg$currPos = s5;
        s5 = peg$FAILED;
      }
      if (s5 as any !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s6 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s6 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c126); }
        }
        if (s6 as any !== peg$FAILED) {
          s5 = [s5, s6];
          s4 = s5;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      while (s4 as any !== peg$FAILED) {
        s3.push(s4);
        s4 = peg$currPos;
        s5 = peg$currPos;
        peg$silentFails++;
        s6 = peg$parseCDataEnd();
        peg$silentFails--;
        if (s6 as any === peg$FAILED) {
          s5 = undefined;
        } else {
          peg$currPos = s5;
          s5 = peg$FAILED;
        }
        if (s5 as any !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c126); }
          }
          if (s6 as any !== peg$FAILED) {
            s5 = [s5, s6];
            s4 = s5;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
      }
      if (s3 as any !== peg$FAILED) {
        peg$savedPos = s2;
        s3 = peg$c131();
      }
      s2 = s3;
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseCDataEnd();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c132(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c130); }
    }

    return s0;
  }

  function peg$parseTagTextContent(): any {
    let s0, s1;

    s0 = peg$currPos;
    s1 = peg$parseCData();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parseTagValue();
    }
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c133(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseEndTag(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseLeftArrow();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseBackSlash();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseTagName();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseRightArrow();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c46(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c134); }
    }

    return s0;
  }

  function peg$parse_(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = [];
    if (peg$c136.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c137); }
    }
    while (s1 as any !== peg$FAILED) {
      s0.push(s1);
      if (peg$c136.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c137); }
      }
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c135); }
    }

    return s0;
  }


      /* eslint-disable @typescript-eslint/no-unused-vars */

      const { defaultUrl, version } = options;

      const startIndicator = '{';
      const endIndicator = '}';
      const indicatorName = '[^' + endIndicator + ']+';
      const escapeRegexp = '\\';
      const nameRegexp = escapeRegexp + startIndicator + indicatorName + escapeRegexp + endIndicator;
      const indicatorSplitterRegexp = '\\s*\\.\\s*';
      const indicatorRegexp = '(?:' + nameRegexp + indicatorSplitterRegexp + ')?' + nameRegexp;

      function isObject(item) {
          return item && typeof item === 'object' && !Array.isArray(item);
      }

      function mergeDeep(sources) {
          if (!sources?.length) {
              return undefined;
          }

          const target = {};

          for (const source of sources) {
              if (source === null || source === undefined || !isObject(source)) {
                  continue;
              }

              for (const key in source) {
                  if (target[key] === null || target[key] === undefined) {
                      Object.assign(target, { [key]: source[key] });
                  } else if (isObject(target[key]) && isObject(source[key])) {
                      target[key] = mergeDeep([target[key], source[key]]);
                  } else if (Array.isArray(target[key]) && Array.isArray(source[key])) {
                      const set = new Set(target[key]);
                      source[key].forEach(set.add, set);
                      target[key] = Array.from(set).sort();
                  } else {
                      target[key] = source[key];
                  }
              }
          }

          return target;
      }

      function mergeParameters(sources) {
          if (!sources?.length) {
              return undefined;
          }

          const replaceOnlyFields = new Set(['text', 'column']);
          const target = {};

          for (const source of sources) {
              if (source === null || source === undefined || !isObject(source)) {
                  continue;
              }

              for (const key in source) {
                  if (replaceOnlyFields.has(key) || !isObject(target[key]) || !isObject(source[key])) {
                      target[key] = source[key];
                  } else {
                      target[key] = mergeDeep([target[key], source[key]]);
                  }
              }
          }

          return target;
      }

      function validateTemplateArgument(parameter) {
          return !!parameter && /^\s*\{[^}]+\s*$/.test(parameter);
      }

      function validateFormula(body, originalBody) {
          if (!body) {
              return;
          }

          try {
              new Function(body);
          } catch (error) {
              throw new Error(
                  `Formula "${originalBody ?? body}" is incorrect, error: "${error.message}"`,
              );
          }
      }

      function validateScript(body) {
          if (!body) {
              return;
          }

          try {
              new Function(body)();
          } catch (error) {
              throw new Error(`Scope "${body}" is incorrect, error: "${error.message}"`);
          }
      }

      function validateTemplates(templates) {
          if (!templates || !templates.length) {
              return;
          }

          const names = new Set();

          for (let { name } of templates) {
              if (!name) {
                  throw new Error('Template has empty name' + JSON.stringify(name));
              }

              if (names.has(name)) {
                  throw new Error(`Templates has same name '${name}'`);
              }

              names.add(name);
          }
      }

      function isEmptyObject(object) {
          return (
              !!object &&
              Object.keys(object).length === 0 &&
              Object.getPrototypeOf(object) === Object.prototype
          );
      }

      function hasAgeProperty(text) {
          return /(^|\W)age\s*\(/.test(text);
      }

      function parseIndicator(name) {
          return [...name.matchAll(new RegExp(nameRegexp, 'g'))].map(([part]) =>
              part.replace(startIndicator, '').replace(endIndicator, '').trim(),
          );
      }

      function normalizedIndicatorName(parts) {
          return parts.map((part) => `{${part}}`).join('.');
      }

      function getFullBody(functionBody) {
          return /^return\s/.test(functionBody) ? functionBody : `return ${functionBody}`;
      }

      function normalizeFormula(formulaText) {
          return formulaText?.replaceAll(new RegExp(indicatorRegexp, 'g'), (indicatorCondition) =>
              normalizedIndicatorName(parseIndicator(indicatorCondition)),
          );
      }

      function parseFormula(formulaText) {
          const indicators = new Set();

          const original = normalizeFormula(formulaText);

          const functionBody = original
              .replaceAll(new RegExp(indicatorRegexp, 'g'), (indicatorCondition) => {
                  const indicatorParts = parseIndicator(indicatorCondition);
                  const indicatorName = normalizedIndicatorName(indicatorParts);

                  indicators.add(indicatorName);

                  return `getIndicatorValue(indicators, '${indicatorName}' + \`.{\${backtestingRunId ?? 0}}\`)`;
              })
              .trim();

          validateFormula(functionBody, original);

          if (indicators.size === 0) {
              throw new Error(`Formula '${original || functionBody}' doesn't contain indicator`);
          }

          return {
              original,
              functionBody: getFullBody(functionBody),
              indicators: Array.from(indicators).sort(),
              hasTimeout: hasAgeProperty(functionBody),
          };
      }

      function filterAndUnwrap(array, objectType) {
          return array?.filter(({ type }) => type === objectType)?.map(({ value }) => value);
      }

      function wrap(obj, objectType) {
          return { value: obj, type: objectType };
      }

      function identity(value) {
          return value;
      }

      function getCellIndicators(conditions, parameters) {
          const indicatorsSet = new Set();

          conditions.forEach(({ condition, parameters }) => {
              condition.indicators?.forEach(indicatorsSet.add, indicatorsSet);
              parameters?.text?.formula?.indicators?.forEach(indicatorsSet.add, indicatorsSet);
          });

          parameters?.text?.formula?.indicators?.forEach(indicatorsSet.add, indicatorsSet);

          return Array.from(indicatorsSet).sort();
      }

      function isTimerUpdatableCell(conditions, parameters) {
          return (
              (conditions?.some(({ condition: { hasTimeout = false } }) => hasTimeout) ?? false) ||
              (parameters?.text?.formula?.hasTimeout ?? false)
          );
      }

      function getTemplate(useTemplate, templates) {
          const template = templates?.find(
              ({ name }) => name.trim().toUpperCase() === useTemplate.name.trim().toUpperCase(),
          );

          if (!template) {
              throw new Error(`Template with name '${useTemplate.name.trim()}' is not found`);
          }

          if ((template.args?.length ?? 0) !== (useTemplate.args?.length ?? 0)) {
              throw new Error(
                  `Template with name '${template.name.trim()}' has different number of parameters provided in use-template`,
              );
          }

          const replaceArgsMap = template.args.reduce(
              (acc, from, index) => ({
                  ...acc,
                  [from]: useTemplate.args[index],
              }),
              {},
          );

          function fixFormula(oldFormula) {
              return normalizeFormula(oldFormula).replace(
                  new RegExp(indicatorRegexp, 'g'),
                  function (from) {
                      const to = replaceArgsMap[from];

                      if (!to) {
                          return from;
                      }

                      return to;
                  },
              );
          }

          const parameters = template.parameters ? { ...template.parameters } : undefined;

          if (parameters.text?.formula?.original) {
              parameters.text = {
                  ...parameters.text,
                  formula: parseFormula(fixFormula(parameters.text.formula.original)),
              };
          }

          const conditions =
              Array.isArray(template.conditions) && template.conditions.length > 0
                  ? template.conditions
                        .map(({ condition, parameters }) => {
                            if (isEmptyObject(parameters)) {
                                return undefined;
                            }

                            const formula = parseFormula(fixFormula(condition.original));

                            return parameters.text?.formula?.original
                                ? {
                                      condition: formula,
                                      parameters: {
                                          ...parameters,
                                          text: {
                                              ...parameters.text,
                                              formula: parseFormula(
                                                  fixFormula(parameters.text.formula.original),
                                              ),
                                          },
                                      },
                                  }
                                : { condition: formula, parameters };
                        })
                        .filter((identity) => identity)
                  : undefined;

          const result = {};

          if (parameters) {
              Object.assign(result, { parameters });
          }
          if (conditions) {
              Object.assign(result, { conditions });
          }

          return isEmptyObject(result) ? undefined : result;
      }

      function applyCellTemplate(cell, templates) {
          if (!cell?.useTemplates?.length) {
              return cell;
          }

          const { useTemplates, ...rest } = cell;

          const cellTemplates = useTemplates
              .map((useTemplate) => getTemplate(useTemplate, templates))
              .filter((identity) => identity)
              .reduce(
                  ({ parameters, conditions }, template) => ({
                      parameters: mergeParameters([parameters, template.parameters]),
                      conditions:
                          conditions && template.conditions
                              ? [...conditions, ...template.conditions]
                              : conditions ?? template.conditions,
                  }),
                  {},
              );

          const parameters = mergeParameters([cellTemplates.parameters, cell.parameters]);
          const conditions =
              cellTemplates.conditions && cell.conditions
                  ? [...cellTemplates.conditions, ...cell.conditions]
                  : cellTemplates.conditions ?? cell.conditions;

          const indicators = getCellIndicators(conditions, parameters);
          const hasTimeout = isTimerUpdatableCell(conditions, parameters);

          return {
              ...rest,
              parameters,
              conditions,
              indicators,
              hasTimeout,
          };
      }

      function applyCellsTemplate(cells, templates) {
          return cells?.map((cell) => applyCellTemplate(cell, templates));
      }

      function applyCellTemplateInRow(row, templates) {
          const cells = applyCellsTemplate(row.cells, templates);
          const rows =
              Array.isArray(row.rows) && row.rows.length
                  ? applyCellTemplateInRows(row.rows, templates)
                  : undefined;

          const allIndicatorsSet = new Set(row.allIndicators);

          cells?.forEach(({ indicators }) => indicators?.forEach(allIndicatorsSet.add, allIndicatorsSet));
          rows?.forEach(({ allIndicators }) =>
              allIndicators?.forEach(allIndicatorsSet.add, allIndicatorsSet),
          );

          const hasTimeout =
              row.hasTimeout ||
              (cells?.some(({ hasTimeout }) => hasTimeout) ?? false) ||
              (rows?.some(({ hasTimeout }) => hasTimeout) ?? false);

          return {
              ...row,
              allIndicators: Array.from(allIndicatorsSet).sort(),
              rows,
              cells,
              hasTimeout,
          };
      }

      function applyCellTemplateInRows(rows, templates) {
          return rows?.map((row) => applyCellTemplateInRow(row, templates));
      }

      function validateSources(indicators, urlSource) {
          for (const parts of indicators?.map((indicator) => parseIndicator(indicator)) ?? []) {
              if (parts.length < 2) {
                  continue;
              }

              if (!(parts[0] in urlSource)) {
                  throw new Error(
                      `Source "${parts[0]}" is missing in registered sources. Source is case sensitive.`,
                  );
              }
          }
      }

      function fixIndicatorNames(entity, urlSource) {
          if (!isObject(entity)) {
              return;
          }

          entity.rows?.forEach((row) => fixIndicatorNames(row, urlSource));
          entity.cells?.forEach((cell) => fixIndicatorNames(cell, urlSource));
          entity.conditions?.forEach((condition) => {
              fixIndicatorNames(condition, urlSource);
              fixIndicatorNames(condition?.condition, urlSource);
          });
          fixIndicatorNames(entity.parameters?.text?.formula, urlSource);

          const convertIndicator = (indicator) => {
              const parts = parseIndicator(indicator);

              if (parts.length === 1) {
                  return { url: defaultUrl, name: parts[0] };
              }
              if (parts.length === 2) {
                  return { url: urlSource[parts[0]], name: parts[1] };
              }
              throw new Error(`Wrong indicator name - "${indicator}"`);
          };

          entity.allIndicators = entity.allIndicators?.map(convertIndicator);
          entity.indicators = entity.indicators?.map(convertIndicator);
      }

      function fixFormulaIndicators(entity, urlSource) {
          if (!isObject(entity)) {
              return;
          }

          entity.rows?.forEach((row) => fixFormulaIndicators(row, urlSource));
          entity.cells?.forEach((cell) => fixFormulaIndicators(cell, urlSource));
          entity.conditions?.forEach((condition) => {
              fixFormulaIndicators(condition, urlSource);
              fixFormulaIndicators(condition?.condition, urlSource);
              fixFormulaIndicators(condition.parameters?.text?.formula, urlSource);
          });

          fixFormulaIndicators(entity.parameters?.text?.formula, urlSource);

          if ('functionBody' in entity) {
              const { functionBody } = entity;
              delete entity.functionBody;

              const bodyArgument = functionBody.replaceAll(
                  new RegExp("'" + indicatorRegexp + "'", 'g'),
                  (indicatorCondition) => {
                      const parts = parseIndicator(indicatorCondition);

                      if (parts.length === 2) {
                          parts[0] = urlSource[parts[0]];
                      } else if (parts.length === 1) {
                          parts.unshift(defaultUrl);
                      }

                      return "'" + normalizedIndicatorName(parts) + "'";
                  },
              );

              entity.constructorArguments = ['indicators', 'backtestingRunId', bodyArgument];
          }
      }

      function postProcessResultObject(entity, urlSource) {
          fixIndicatorNames(entity, urlSource);
          fixFormulaIndicators(entity, urlSource);

          return entity;
      }

      function processTableCellTemplate(template) {
          const [name] = filterAndUnwrap(template, 'name').slice(-1);

          if (!name) {
              throw new Error('Template name is mandatory');
          }

          const args = filterAndUnwrap(template, 'args')?.flat() ?? [];

          const parameters = mergeParameters(filterAndUnwrap(template, 'parameters')) ?? {};
          const conditions = filterAndUnwrap(template, 'conditions');

          return {
              name,
              args,
              parameters,
              conditions,
          };
      }

      function processTableCell(cell) {
          const parameters = mergeParameters(filterAndUnwrap(cell, 'parameters')) ?? {};
          const conditions = filterAndUnwrap(cell, 'conditions');
          const useTemplates = filterAndUnwrap(cell, 'templates');

          const indicators = getCellIndicators(conditions, parameters);
          const hasTimeout = isTimerUpdatableCell(conditions, parameters);

          return {
              parameters,
              conditions,
              indicators,
              hasTimeout,
              useTemplates,
          };
      }

      function processTableRow(row) {
          const parameters = mergeParameters(filterAndUnwrap(row, 'parameters')) ?? {};
          const conditions = filterAndUnwrap(row, 'conditions');
          const cells = filterAndUnwrap(row, 'cells');
          const rows = filterAndUnwrap(row, 'rows');

          const indicatorsSet = new Set();
          conditions.forEach(({ condition }) =>
              condition.indicators?.forEach(indicatorsSet.add, indicatorsSet),
          );

          const indicators = Array.from(indicatorsSet).sort();

          const allIndicatorsSet = new Set(indicatorsSet);
          cells?.forEach(({ indicators }) => indicators?.forEach(allIndicatorsSet.add, allIndicatorsSet));
          rows?.forEach(({ allIndicators }) =>
              allIndicators?.forEach(allIndicatorsSet.add, allIndicatorsSet),
          );

          const allIndicators = Array.from(allIndicatorsSet).sort();

          const hasTimeout =
              (cells?.some(({ hasTimeout }) => hasTimeout) ?? false) ||
              (rows?.some(({ hasTimeout }) => hasTimeout) ?? false) ||
              (conditions?.some(({ condition: { hasTimeout = false } }) => hasTimeout) ?? false);

          const rowsCells = rows?.reduce((max, row) => Math.max(max, row.columnsCount ?? 0), 0);
          const columnsCount = Math.max(rowsCells > 0 ? rowsCells + 1 : 0, cells.length);

          if (rows?.length > 0) {
              return {
                  rowsCells: rowsCells > 0 ? rowsCells + 1 : 0,
                  allIndicators,
                  indicators,
                  parameters,
                  conditions,
                  rows,
                  cells,
                  hasTimeout,
                  columnsCount,
              };
          }

          return {
              allIndicators,
              indicators,
              parameters,
              conditions,
              cells,
              hasTimeout,
              columnsCount,
          };
      }

      function processTableContent(table) {
          const parameters = mergeParameters(filterAndUnwrap(table, 'parameters'));
          const conditions = filterAndUnwrap(table, 'conditions');
          const rawRows = filterAndUnwrap(table, 'rows');
          const scope =
              filterAndUnwrap(table, 'scope')
                  ?.filter((scope) => scope)
                  ?.join('') || undefined;
          const templates = filterAndUnwrap(table, 'templates') ?? [];
          const urlSource =
              filterAndUnwrap(table, 'sources')?.reduce((acc, { name, url }) => {
                  if (name in acc) {
                      throw new Error(`Multiple sources with same name '${name}'`);
                  }

                  acc[name] = url;

                  return acc;
              }, {}) ?? {};

          const rows = applyCellTemplateInRows(rawRows, templates);

          validateTemplates(templates);

          const indicatorsSet = new Set();
          conditions?.forEach(({ condition: { indicators } }) =>
              indicators?.forEach(indicatorsSet.add, indicatorsSet),
          );

          const indicators = Array.from(indicatorsSet).sort();

          const allIndicatorsSet = new Set(indicatorsSet);
          rows?.forEach(({ allIndicators }) =>
              allIndicators?.forEach(allIndicatorsSet.add, allIndicatorsSet),
          );

          const allIndicators = Array.from(allIndicatorsSet).sort();

          const hasTimeout =
              (rows?.some(({ hasTimeout }) => hasTimeout) ?? false) ||
              (conditions?.some(({ condition: { hasTimeout = false } }) => hasTimeout) ?? false);

          const maxRowColumnsCount = rows?.reduce((max, row) => Math.max(max, row.columnsCount), 0) ?? 0;

          validateSources(allIndicators, urlSource);

          return postProcessResultObject(
              {
                  allIndicators,
                  indicators,
                  parameters: { ...parameters, maxRowColumnsCount },
                  conditions,
                  rows,
                  hasTimeout,
                  scope,
                  version,
              },
              urlSource,
          );
      }

      function processGridCellTemplate(template) {
          const [name] = filterAndUnwrap(template, 'name').slice(-1);

          if (!name) {
              throw new Error('Template name is mandatory');
          }

          const args = filterAndUnwrap(template, 'args')?.flat() ?? [];

          const parameters = mergeParameters(filterAndUnwrap(template, 'parameters')) ?? {};
          const conditions = filterAndUnwrap(template, 'conditions');

          return {
              name,
              args,
              parameters,
              conditions,
          };
      }

      function processGridCell(cell) {
          const parameters = mergeParameters(filterAndUnwrap(cell, 'parameters')) ?? {};
          const conditions = filterAndUnwrap(cell, 'conditions');
          const useTemplates = filterAndUnwrap(cell, 'templates');

          const indicators = getCellIndicators(conditions, parameters);
          const hasTimeout = isTimerUpdatableCell(conditions, parameters);

          return {
              parameters,
              conditions,
              indicators,
              hasTimeout,
              useTemplates,
          };
      }

      function processGridContent(grid) {
          const parameters = mergeParameters(filterAndUnwrap(grid, 'parameters'));
          const conditions = filterAndUnwrap(grid, 'conditions');
          const rawCells = filterAndUnwrap(grid, 'cells');
          const scope =
              filterAndUnwrap(grid, 'scope')
                  ?.filter((scope) => scope)
                  ?.join('') || undefined;
          const templates = filterAndUnwrap(grid, 'templates') ?? [];
          const urlSource =
              filterAndUnwrap(grid, 'sources')?.reduce((acc, { name, url }) => {
                  if (name in acc) {
                      throw new Error(`Multiple sources with same name '${name}'`);
                  }

                  acc[name] = url;

                  return acc;
              }, {}) ?? {};

          const cells = applyCellsTemplate(rawCells, templates);

          validateTemplates(templates);

          const indicatorsSet = new Set();
          conditions.forEach(({ condition: { indicators } }) =>
              indicators?.forEach(indicatorsSet.add, indicatorsSet),
          );

          const indicators = Array.from(indicatorsSet).sort();

          const allIndicatorsSet = new Set(indicatorsSet);
          cells.forEach(({ indicators }) => indicators?.forEach(allIndicatorsSet.add, allIndicatorsSet));

          const allIndicators = Array.from(allIndicatorsSet).sort();

          const columnsCount =
              parameters?.columnsCount ??
              Math.max(
                  ...(cells
                      ?.filter(({ parameters }) => parameters?.column !== undefined)
                      ?.map(({ parameters }) => parameters.column) || []),
                  1,
              );

          const hasTimeout =
              conditions?.some(({ condition: { hasTimeout = false } }) => hasTimeout) ?? false;

          validateSources(allIndicators, urlSource);

          return postProcessResultObject(
              {
                  allIndicators,
                  indicators,
                  parameters: { ...parameters, columnsCount },
                  conditions,
                  cells: cells?.map((cell) => applyCellTemplate(cell, templates)),
                  scope,
                  hasTimeout,
                  version,
              },
              urlSource,
          );
      }

      function processGridColumnsCount(text) {
          const count = parseInt(text, 10);
          return { columnsCount: isNaN(count) ? undefined : count };
      }

      function processGridColumn(text) {
          if (!text?.trim()) {
              return { column: undefined };
          }

          const value = parseInt(text, 10);

          if (isNaN(value)) {
              return { column: undefined };
          }

          return { column: value };
      }

      function processMark(parameters) {
          return { mark: mergeDeep(parameters) ?? {} };
      }

      function processFormula(formula) {
          return { formula: formula ? parseFormula(formula) : undefined };
      }

      function processFormat(format) {
          return { format: format || undefined };
      }

      function processFormattedText(parameters) {
          const { format = undefined, formula = undefined } = mergeDeep(parameters);
          return { format, formula };
      }

      function processDisplayValue(value) {
          if (value === null || value === undefined) {
              return { text: undefined };
          }

          return { text: value };
      }

      function processTooltip(tooltip) {
          return { tooltip: tooltip || undefined };
      }

      function processEmptyStyleItem(startTag) {
          const styleName = startTag.replace(/[\W|_]+(\w)/g, (_, firstGroupLetter) =>
              firstGroupLetter.toUpperCase(),
          );

          return { [styleName]: null };
      }

      // Lodash realization of kebabCase
      const rsAstralRange = '\\ud800-\\udfff';
      const rsComboMarksRange = '\\u0300-\\u036f';
      const reComboHalfMarksRange = '\\ufe20-\\ufe2f';
      const rsComboSymbolsRange = '\\u20d0-\\u20ff';
      const rsComboMarksExtendedRange = '\\u1ab0-\\u1aff';
      const rsComboMarksSupplementRange = '\\u1dc0-\\u1dff';
      const rsComboRange =
          rsComboMarksRange +
          reComboHalfMarksRange +
          rsComboSymbolsRange +
          rsComboMarksExtendedRange +
          rsComboMarksSupplementRange;
      const rsDingbatRange = '\\u2700-\\u27bf';
      const rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff';
      const rsMathOpRange = '\\xac\\xb1\\xd7\\xf7';
      const rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf';
      const rsPunctuationRange = '\\u2000-\\u206f';
      const rsSpaceRange =
          ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000';
      const rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde';
      const rsVarRange = '\\ufe0e\\ufe0f';
      const rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

      const rsApos = "['\u2019]";
      const rsBreak = `[${rsBreakRange}]`;
      const rsCombo = `[${rsComboRange}]`;
      const rsDigit = '\\d';
      const rsDingbat = `[${rsDingbatRange}]`;
      const rsLower = `[${rsLowerRange}]`;
      const rsMisc = `[^${rsAstralRange}${
          rsBreakRange + rsDigit + rsDingbatRange + rsLowerRange + rsUpperRange
      }]`;
      const rsFitz = '\\ud83c[\\udffb-\\udfff]';
      const rsModifier = `(?:${rsCombo}|${rsFitz})`;
      const rsNonAstral = `[^${rsAstralRange}]`;
      const rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}';
      const rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]';
      const rsUpper = `[${rsUpperRange}]`;
      const rsZWJ = '\\u200d';

      const rsMiscLower = `(?:${rsLower}|${rsMisc})`;
      const rsMiscUpper = `(?:${rsUpper}|${rsMisc})`;
      const rsOptContrLower = `(?:${rsApos}(?:d|ll|m|re|s|t|ve))?`;
      const rsOptContrUpper = `(?:${rsApos}(?:D|LL|M|RE|S|T|VE))?`;
      const reOptMod = `${rsModifier}?`;
      const rsOptVar = `[${rsVarRange}]?`;
      const rsOptJoin = `(?:${rsZWJ}(?:${[rsNonAstral, rsRegional, rsSurrPair].join('|')})${
          rsOptVar + reOptMod
      })*`;
      const rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])';
      const rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])';
      const rsSeq = rsOptVar + reOptMod + rsOptJoin;
      const rsEmoji = `(?:${[rsDingbat, rsRegional, rsSurrPair].join('|')})${rsSeq}`;

      const reUnicodeWords = RegExp(
          [
              `${rsUpper}?${rsLower}+${rsOptContrLower}(?=${[rsBreak, rsUpper, '$'].join('|')})`,
              `${rsMiscUpper}+${rsOptContrUpper}(?=${[rsBreak, rsUpper + rsMiscLower, '$'].join('|')})`,
              `${rsUpper}?${rsMiscLower}+${rsOptContrLower}`,
              `${rsUpper}+${rsOptContrUpper}`,
              rsOrdUpper,
              rsOrdLower,
              `${rsDigit}+`,
              rsEmoji,
          ].join('|'),
          'g',
      );

      function unicodeWords(str) {
          return str.match(reUnicodeWords);
      }

      const hasUnicodeWord = RegExp.prototype.test.bind(
          /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
      );

      const reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

      function asciiWords(string) {
          return string.match(reAsciiWord);
      }

      function words(string, pattern) {
          if (pattern === undefined) {
              const result = hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
              return result || [];
          }
          return string.match(pattern) || [];
      }

      function kebabCase(str) {
          return words(str)
              .map((word) => word.toLowerCase())
              .join('-');
      }

      function processStyleItem(startTag, content, endTag) {
          if (startTag !== endTag) {
              throw new Error(`Start tag "${startTag}" doesn't match end tag "${endTag}"`);
          }

          const styleName = startTag.replace(/[\W|_]+(\w)/g, (_, firstGroupLetter) =>
              firstGroupLetter.toUpperCase(),
          );

          const styleValue = content?.trim() || null;

          if (styleValue === null) {
              return { [styleName]: null };
          }

          const browserCssPropertyName = kebabCase(styleName);

          if (!CSS.supports(browserCssPropertyName, styleValue)) {
              throw new Error(
                  `Not supported value of the CSS property "${styleValue}" for CSS property "${browserCssPropertyName}"`,
              );
          }

          return { [styleName]: styleValue };
      }

      function processStyle(styles) {
          return {
              style: styles.reduce((acc, style) => ({ ...acc, ...style }), {}),
          };
      }

      function processScriptScope(scope) {
          validateScript(scope);

          return scope?.trim() || undefined;
      }

      function processConditionExpression(condition) {
          return parseFormula(condition);
      }

      function processTemplateArgument(argument, maxParts = 2) {
          validateTemplateArgument(argument);

          const parts = parseIndicator(argument);

          if (parts.length > maxParts) {
              throw new Error(`Name shouldn't have more than ${maxParts} parts: '${argument}'`);
          }

          return normalizedIndicatorName(parts);
      }

      function processTemplateArguments(args) {
          return (args ?? []).filter(identity);
      }

      function processRequiredValue(name, objectName) {
          if (!name?.trim()) {
              throw new Error(`${objectName} can't be empty`);
          }
          return name.trim();
      }

      function processTemplateUseContent(name, args) {
          return { name, args };
      }

      function processSource(name, url) {
          return { name, url };
      }


  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }

    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
    );
  }
}

export interface IParseOptions {
  filename?: string;
  startRule?: string;
  tracer?: any;
  [key: string]: any;
}
export type ParseFunction = (input: string, options?: IParseOptions) => any;
export const parse: ParseFunction = peg$parse;

